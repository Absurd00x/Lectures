# Итерабельный объект - это объект, который состоит
# из нескольких значений.
# Например, list, tuple, str, set, dict, range

# Существует особая функция map()
# Она принимает два ОБЪЕКТА - функцию
# и итерабельный объект. Делает из них промежуточный
# объект типа map, который должен будет приненить
# данную функцию ко всем объектам
# итерабельного объекта
print(map(int, ["1", "2", "3"]))

# Чтобы получить настоящий объект, тебе нужно указать
# что за объект ты ожидаешь увидеть. Список, кортеж
# или ещё что. В основном списки
arr = list(map(int, ["1", "2", "3"]))
print(arr)

# У строки существует метод .split(разделитель). Он
# разделяет данную строку по данному разделителю
# и получает список (list) из строчек. Если ничего
# не указывать как разделитель, то разделителем
# считается пробел.
a = "lol kek cheburek"
print(a.split())

# Наконец, чтобы прочитать строчку из чисел, можно
# написать:
arr = list(map(int, input().split()))

# Есть и другой способ использующий особую конструкцию
# "генератор списка". Эта конструкция создаёт
# список по какому-то правилу. Почти как map, только
# генератор списка сразу делает список, а не
# промежуточный объект
s = "1 2 3 4 5"
arr = [int(num) for num in s.split()]

# Итерация по нескольким объектам
# Пускай у тебя был список пар
arr = [(1, 2), (3, 4), (5, 6)]
# Хочется сразу пользоваться первым числом из
# пары и вторым. Для этого написать такой for:
for first, second in arr:
  print(first, '!!!', second)
# Это называется распаковкой значений. Можно и без
# цикла:
first, second = arr[0]
print(first, second)

d = {"Петя": 1, "Вася": 2, "Таня": 3}
# у словаря есть методы .keys(), .values() и .items().
# Они создают промежуточные объекты на набор ключей,
# значений и пар (ключ, значение) соответственно
print(d.keys())
print(d.values())
print(d.items())
# Проитерироваться в цикле for можно и по
# промежуточному объекту. Тогда он явно не будет
# создаваться. Это как раз "сэкономит" память,
# но ты сэкономишь спички.
for key, value in d.items():
  print(key, value)


# Если в словаре нет ключа и ты захотел его изменить,
# то будет ошибка. Нужно сначала создать объект,
# а потом его изменять.

if "Галя" in d:
  print("Присутствует")
  d["Галя"] += 4
else:
  print("Отсутствует")
  d["Галя"] = 4

print(d["Галя"])

if "Галя" in d:
  print("Присутствует")
  d["Галя"] += 4
else:
  print("Отсутствует")
  d["Галя"] = 4

print(d["Галя"])