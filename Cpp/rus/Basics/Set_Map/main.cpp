#include <bits/stdc++.h>
// библиотеки можно подключать дважды
// компилятор разберётся
// для работы с множествами
#include <set>
// для работы с отображениями
#include <map>

using namespace std;

// O(n)
int get_position_in_multiset(multiset<int> &ms, auto iter) {
  int res = 0;
  while (iter != ms.begin()) {
    --iter;
    ++res;
  }
  return res;
}

int main() {
  // множество - неконтролируемый набор значений
  // в нём элементы по умолчанию будут располагаться "от меньшего к большему"
  // у множества нет индексов, но есть итераторы
  // в множестве каждый элемент хранится один раз
  // объявляется так:
  // set<тип_элементов> название_множества;

  set<int> st;
  // так тоже можно объявлять массивы (и всё остальное тоже)
  // в том числе и множества
  // такой способ называется "списком инициализации"
  vector<int> arr = {2, 3, 1, 2, 3, 1};
  // в множество можно добавлять элементы, удалять из него элементы
  // и искать в нём элементы намного быстрее, чем в массиве
  for (int i = 0; i < (int)arr.size(); ++i) {
    // добавить элемент в множество можно методом .insert()
    // если в множестве уже был такой элемент, то ничего не произойдёт
    st.insert(arr[i]);
  }
  // пройтись по элементам множества можно двумя способами
  // во-первых, можно использовать итераторы:
  cout << "Set contents:" << endl;
  for (auto it = st.begin(); it != st.end(); ++it) {
    cout << (*it) << ' ';
  }
  cout << endl;
  // во-вторых, в плюсах есть "питонячие" форики
  // он пишется так:
  // for (тип_элемента название_перемнной : массив) {
  // вместо типа можно писать auto
  cout << "Set contents:" << endl;
  for (int elem : st) {
    cout << elem << ' ';
  }
  cout << endl << endl;
  // из множества можно удалить элементы методом .erase()
  for (int i = 0; i < (int)arr.size(); ++i) {
    // если элемента нет в множестве, то ничего не случится
    st.erase(arr[i]);
  }
  // можно посчитать количество элементов num методом .count(num)
  // звучит глупо, потому что элемент либо есть в множестве,
  // либо его нет
  // поэтому функция вернёт либо 1, либо 0
  cout << "There are " << st.count(1337) << " elems in set equal to 1337" << endl;
  // можно попробовать найти конкретный элемент в множестве методом .find()
  // он вернёт итератор на найденный элемент, а если не нашел его, то
  // итератор будет равен st.end()
  auto iter = st.find(1337);
  if (iter == st.end()) {
    cout << "1337 not found" << endl << endl;
  }
  // не путай метод .find(elem) с функцией std::find(begin, end, elem)

  // отображение, или "мапа" - массив, у которого вместо индексов может быть
  // всё что можно сравнивать - целые числа, строки, символы, дробные числа и т.д.
  // объявляется так:
  // map<тип_ключа, тип_значения> название_мапы;
  map<int, int> counts;
  // если ключа в мапе не было, а ты к нему обратился, то он создаётся
  // и по умолчанию равен 0 для типа int
  // "попсовый" форик работает с векторами
  for (int elem : arr) {
    ++counts[elem];
  }
  // перед тем, как показать как пройтись по мапе, нужно узнать что такое пары
  // это отдельный тип данных, который включает в себя два других
  // объявляется так:
  // pair<тип_первого_элемента, тип_второго_элемента> имя_пары;
  // с парой тоже работает "список инициализации"
  pair<char, int> example = {'a', 0};
  // чтобы обратиться к первому или ко второму элементу, нужно сделать так:
  cout << "Pair contents:" << endl;
  cout << example.first << ' ' << example.second << endl << endl;
  // теперь к мапе
  // по мапе также можно пройтись с помощью итераторов
  cout << "Map contents:" << endl;
  for (auto it = counts.begin(); it != counts.end(); ++it) {
    // и тут разрыв шаблона - элементы мапы являются парами
    pair<int, int> elem = *it;
    // auto тоже работает
    auto key_value = *it;
    cout << elem.first << ' ' << key_value.second << endl;
  }
  // "питонячий" форик тоже работает и auto тоже и всё в месте тоже:
  cout << "Map contents:" << endl;
  for (auto key_value : counts) {
    cout << key_value.first << ' ' << key_value.second << endl;
  }
  cout << endl;
  // совет: не пытайся удалять элементы из сета/мапы, когда по ним проходишься
  for (int elem : arr) {
    // чтобы удалить элемент, то нужно указать его "ключ"
    // это то, что у мапы вместо индекса
    // значение указывать не нужно
    counts.erase(elem);
  }
  // .insert(), .erase(), .find(), .count() работают у этих структур
  // за O(log(n)), где n - количество элементов в сете/мапе
  // Обращение к элементу в мапе через [] тоже стоит O(log(n))
  // если интересно, то под этими структурами в c++ скрывается
  // красно-чёрное дерево (КЧД): https://ru.wikipedia.org/wiki/Красно-чёрное_дерево

  // ещё может пригодиться структура мультимножества
  // объявляется так:
  multiset<int> ms;
  // она очень похожа на множество, но
  // в МУЛЬТИмножестве один и тот же элемент может храниться сколько хочешь раз
  for (int i = 0; i < 10; ++i) {
    ms.insert(0);
  }
  cout << "Initial multiset size = " << ms.size() << endl;
  // и метод .count() честно считает каждый элемент, поэтому асимптотика
  // его работы равна O(n) в худшем случае (когда все элементы одинаковые)
  // также если хочешь удалить элемент, то есть две ситуации:
  // 1. Ты удаляешь один элемент, тогда передаёшь итератор на него:
  ms.erase(ms.begin());
  cout << "Multiset size after .begin() erased = " << ms.size() << endl;
  // 2. Ты говоришь какие элементы хочешь удалить
  // тут я говорю "удали самые маленькие элементы"
  int val = *ms.begin();
  ms.erase(val);
  cout << "Multiset size after smallest elements are erased = " << ms.size() << endl;
  cout << endl;

  // теперь аналогии с вектором
  // у вектора можно было прибавлять число x к итератору и получать
  // итератор на элемент, который стоит через x позиций
  // в этом примере берём итератор на первый элемент, затем находим
  // элемент через 3 позиции
  // это эквивалентно arr[0 + 3]
  cout << "Element at index 3 equals to ";
  cout << (*(arr.begin() + 3)) << endl;
  // такое прибавление числа к итератору происходит за O(1), то есть за константу
  // но вот в set/map/multiset это происходит за O(n), так как там
  // элементы стоят не как в роте, подряд, а в виде дерева
  // ДОСКА!!!!!!

  // у структур выше есть очень полезные методы
  // .lower_bound(num) и .upper_bound(num)
  // первая возвращает итератор на первый элемент, который не меньше num
  // вторая возвращает итератор на первый элемент, который больше num
  // помним, что переменные можно переприсваивать
  ms = {1, 2, 3, 3, 4, 5};
  cout << "Multiset contents are:" << endl;
  for (int num : ms) {
    cout << num << ' ';
  }
  cout << endl << endl;
  auto it = ms.lower_bound(3);
  int pos = get_position_in_multiset(ms, it);
  cout << ".lower_bound(3) returns iterator at position " << pos << endl;
  cout << "which points at " << (*it) << endl << endl;
  it = ms.upper_bound(3);
  pos = get_position_in_multiset(ms, it);
  cout << ".upper_bound(3) returns iterator at position " << pos << endl;
  cout << "which points at " << (*it) << endl << endl;

  // разберём как под капотом работает вектор
  // вот у тебя есть рота элементов
  // arr = {2, 3, 1, 2, 3, 1}
  // в памяти они расположены точно так же подряд
  // если ты захочешь вставить в вектор новый элемент, то
  // чтобы рота не сломалась, нужно, чтобы все элементы СПРАВА
  // сделали шаг вправо, освободили место для нового элемента
  // arr = {2, _, 3, 1, 2, 3, 1}
  // получается, что при вставке нового элемента может сдвинуться
  // порядка O(n) элементов
  // при этом добавление в конец роты происходит за O(1)
  // даже есть отдельный метод для этого push_back()
  // аналогично с удалением
  // если хочешь удалить элемент из роты, то все, кто стоит СПРАВА
  // должны сделать шаг влево
  // это тоже O(n)
  // и удаление из конца тоже стоит всего лишь O(1)
  // чтобы вставить или удалить элемент из середины массива
  // нужно передать итератор на этот элемент
  cout << "Vector contents are:" << endl;
  for (int num : arr) {
    cout << num << ' ';
  }
  cout << endl << endl;
  cout << "Erasing element at index 3..." << endl;
  // arr[0 + 3]
  arr.erase(arr.begin() + 3);
  cout << "Now vector contents are:" << endl;
  for (int num : arr) {
    cout << num << ' ';
  }
  cout << endl << endl;
  cout << "Inserting 1337 at index 1..." << endl;
  // arr[0 + 1]
  arr.insert(arr.begin() + 1, 1337);
  cout << "Now vector contents are:" << endl;
  for (int num : arr) {
    cout << num << ' ';
  }
  cout << endl << endl;

  // ещё один подкапотный момент заключается в том, что у тебя
  // не бесконечное помещение, где находится твоя рота и рано или поздно
  // придётся её перегонять в другой зал
  // вектор хитро написан, поэтому каждый раз, когда ты перегоняешь
  // роту в другой зал, то размер зала увеличивается в 2 раза
  // это специально так сделано, чтобы суммано за все перегоны
  // была асимптотика O(n)
  // она получается следующим образом:
  // пускай изначально у тебя размер роты был 1 и размер зала 1
  // в роту постоянно приходят новые призывники, пока их не станет n
  // в первый раз ты перегонишь 1го призывника, потом 2х, потом 4х
  // т.к. размер зала у тебя каждый раз в 2 раза увеличивается и перегон
  // происходит только когда зал полностью заполнен
  // получается, что суммарно потратим
  // 1 + 2 + 4 + ... + 2^(floor(log(n)))
  // тут floor(x) - округление x вниз
  // это же сумма геометрической прогрессии!
  // пусть floor(log(n)) = k
  // иными словами, k - максимальный показатель степени двойки, на которой
  // произойдёт перегон роты в другой зал
  // 1 + 2 + 4 + ... + 2^k
  // представим числа в двоичном виде, получим
  // 1 + 10 + 100 + ... + 100..00 < 1000..00
  // получится число вида 11..11
  // можно сказать, что это число меньше 2^(k + 1), что как максимум в 2 раза
  // больше числа n, ведь 2^k <= n <= 2^(k + 1)
  // значит, суммарно мы потратим O(2*n) = O(n) операций на перегоны
  // и не нужно волноваться за перегоны, когда добавляешь элементы в конец
  // текущий размер комнаты можно узнать методом .capacity()
  cout << "Vector size is " << arr.size() << endl;
  cout << "Vector capacity is " << arr.capacity() << endl;
  cout << "Adding 123 at the end of array" << endl << endl;
  // добавим элемент
  arr.push_back(123);
  cout << "Now vector size is " << arr.size() << endl;
  cout << "Now vector capacity is " << arr.capacity() << endl;
  return 0;
}

/* Методы сета и их асимптотики:
st.find(elem)    | Итератор на элемент равный elem. st.end(), если его нет       | O(log(n))
st.count(elem)   | Сколько элементов равно elem (0 или 1)                        | O(log(n))
st.size()        | Количество элементов в st                                     | O(1)
st.empty()       | Пустой ли st                                                  | O(1)
st.insert(elem)  | Добавить elem в множество. Если он уже есть, то ничего        | O(log(n))
st.erase(elem)   | Удалить ЭЛЕМЕНТ elem из множества. Если его нет, то ничего    | O(log(n))
st.erase(iter)   | Удалить ИТЕРАТОР iter из множества. Если его нет, то ошибка   | O(log(n))
st.clear()       | Очистить содержимое st                                        | O(n)
st.begin()       | Итератор на первый (самый маленький) элемент                  | O(1)
st.end()         | Итератор на несуществующий (больше самого большого) элемент   | O(1)
st.rbegin()      | Итератор на последний (самый большой) элемент                 | O(1)
st.rend()        | Итератор на несуществующий (меньше самого маленького) элемент | O(1)
*/

/* Методы мапы и их асимптотики:
mp.find(key)     | Итератор на элемент равный elem. mp.end(), если его нет            | O(log(n))
mp.count(key)    | Сколько элементов равно elem (0 или 1)                             | O(log(n))
mp.size()        | Количество элементов в mp                                          | O(1)
mp.empty()       | Пустой ли mp                                                       | O(1)
mp[key]          | Значение по ключу key. Если его до этого не было, то оно создаётся | O(log(n))
mp.erase(key)    | Удалить ЭЛЕМЕНТ elem из множества. Если его нет, то ничего         | O(log(n))
mp.erase(iter)   | Удалить ИТЕРАТОР iter из множества. Если его нет, то ошибка        | O(log(n))
mp.clear()       | Очистить содержимое mp                                             | O(n)
mp.begin()       | Итератор на первый (самый маленький) элемент                       | O(1)
mp.end()         | Итератор на несуществующий (больше самого большого) элемент        | O(1)
mp.rbegin()      | Итератор на последний (самый большой) элемент                      | O(1)
mp.rend()        | Итератор на несуществующий (меньше самого маленького) элемент      | O(1)
*/

/* Методы мультисета и их асимптотики
mst.find(elem)    | Итератор на элемент равный elem. mst.end(), если его нет      | O(log(n))
mst.count(elem)   | Сколько элементов равно elem                                  | O(max(log(n), n)), где n - количество элементов равных elem
mst.size()        | Количество элементов в mst                                    | O(1)
mst.empty()       | Пустой ли mst                                                 | O(1)
mst.insert(elem)  | Добавить elem в множество. Если он уже есть, то ничего        | O(log(n))
mst.erase(elem)   | Удалить ЭЛЕМЕНТ elem из множества. Если его нет, то ничего    | O(log(n))
mst.erase(iter)   | Удалить ИТЕРАТОР iter из множества. Если его нет, то ошибка   | O(log(n))
mst.clear()       | Очистить содержимое mst                                       | O(n)
mst.begin()       | Итератор на первый (самый маленький) элемент                  | O(1)
mst.end()         | Итератор на несуществующий (больше самого большого) элемент   | O(1)
mst.rbegin()      | Итератор на последний (самый большой) элемент                 | O(1)
mst.rend()        | Итератор на несуществующий (меньше самого маленького) элемент | O(1)
*/

/* .lower_bound(num) и .upper_bound(num) есть у set, map, multiset
.lower_bound(num) | Итератор на первый элемент >= num | O(log(n))
.upper_bound(num) | Итератор на первый элемент > num  | O(log(n))
*/
