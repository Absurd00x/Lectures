#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define int ll

void print(int n, int width=0) {
  // width=0 => значение по умолчанию.
  // Второй аргумент (число width) можно не передавать в фукнцию.
  // Тогда оно будет равно 0.
  for (int i = 0; i < n; ++i) {
    if (i) {
      cout << ' ';
      --width;
    }
    if (i < 10) {
      cout << ' ';
    }
    cout << i;
    width -= 2;
  }
  while (width > 0) {
    cout << ' ';
    --width;
  }
}

// Это называется перегрузка функции.
// Когда две функции отличаются списком аргументов,
// а не названием.
void print(vector<int> &arr, int width=0) {
  for (int i = 0; i < (int)arr.size(); ++i) {
    if (i) {
      cout << ' ';
      --width;
    }
    if (0 <= arr[i] && arr[i] < 10) {
      cout << ' ';
    }
    cout << arr[i];
    width -= 2;
  }
  while (width > 0) {
    cout << ' ';
    --width;
  }
}

void print(vector<vector<int>> &mat) {
  int n = (int)mat.size();
  int m = (int)mat[0].size();
  cout << "   |";
  int width = 0;
  for (int j = 0; j < m; ++j) {
    cout << ' ';
    ++width;
    if (j < 10) {
      cout << ' ';
    }
    cout << j;
    width += 2;
  }
  cout << '\n';
  cout << "---+";
  while (width > 0) {
    cout << '-';
    --width;
  }
  cout << '\n';
  for (int i = 0; i < n; ++i) {
    cout << (i < 10 ? " " : "") << i << " |";
    for (int j = 0; j < m; ++j) {
      cout << ' ';
      if (0 <= mat[i][j] && mat[i][j] < 10) {
        cout << ' ';
      }
      cout << mat[i][j];
    }
    cout << '\n';
  }
}

signed main() {
  // Самой простой темой в спортивном программировании
  // являются префиксные суммы. Суть заключается в том,
  // что мы посчитаем один массив:
  // ps[i] = сумма первых i элементов массива.
  // Всё, так просто.

  vector<int> arr = {4, -3, 2, 5, 1};
  // ps[0] = 0
  // ps[1] = arr[0]
  // ps[2] = arr[0] + arr[1]
  // ps[3] = arr[0] + arr[1] + arr[2]
  // Чтобы посчитать префикс-сумму ps[i], нужно взять предыдущую
  // ps[i - 1] и добавить один элемент arr[i - 1]
  // ps[i] = ps[i - 1] + arr[i - 1].
  // Добавим к i единицу в обеих частях. Получим:
  // ps[i + 1] = ps[i] + arr[i]
  int n = (int)arr.size();
  vector<int> ps(n + 1);
  for (int i = 0; i < n; ++i) {
    ps[i + 1] = ps[i] + arr[i];
  }

  // Просто вывод, не обращай внимания...
  const int SPACE = 2 * (n + 1) + n;
  print(n + 1, SPACE);
  cout << " <= " << "Indices" << endl;
  print(arr, SPACE);
  cout << " <= " << "Array" << endl;
  print(ps, SPACE);
  cout << " <= " << "Prefix-sums" << endl;
  cout << endl;

  // С помощью префикс-сумм можно находить сумму на
  // отрезке за O(1). Вот ссылка на задачу:
  // https://codeforces.com/group/U86Pj3Hohe/contest/429290/problem/A

  // Ведь сумму на отрезке можно выразить через префикс-суммы:
  // sum(l, r) = ps[r] - ps[l - 1]
  // sum(l, r) = arr[l - 1] + arr[l] + ... + arr[r - 2] + arr[r - 1]
  // ps[r]     = arr[0] + ... + arr[l - 2] + arr[l - 1] + ... + arr[r - 1]
  // ps[l - 1] = arr[0] + ... + arr[l - 2]
  // ps[r] - ps[l - 1] = arr[l - 1] + ... + arr[r - 1]

  // Смотри файл PS1.png для лучшего понимания.

  // С помощью префикс-сумм решается много задач вида
  // "найди подотрезок, где выполняется условие".
  // Например, найди подотрезок с максимальной суммой. Ссылка:
  // https://codeforces.com/group/U86Pj3Hohe/contest/429290/problem/B

  // Решается так:
  // Сумму на отрезке можно выразить через разность двух префикс-сумм:
  // sum(l, r) = ps[r] - ps[l - 1]
  // sum(l, r) => max
  // ps[r] - ps[l - 1] => max
  // Значит, хотим, чтобы разность двух префикс-сумм была как можно
  // больше. Для этого переберём правую префикс-сумму ps[r], а среди
  // всех левых выберем минимальную. Для этого будем поддерживать
  // минимальную префикс-сумму слева в отдельной переменной.

  // Префикс-суммы можно применить и в двумерном массиве. Тогда:
  // ps[i][j] = сумма первых j элементов в первых i строках
  // Формула для пересчёта хитрая.
  // Смотри файл PS2.png для лучшего понимания

  vector<vector<int>> mat = {
    {14, 4, 6, 7, 11},
    {5, 13, 9, 8, 12},
    {15, 2, 1, 3, 10}
  };
  n = (int)mat.size();
  int m = (int)mat[0].size();
  vector<vector<int>> ps2(n + 1, vector<int>(m + 1));
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
      ps2[i + 1][j + 1] = ps2[i][j + 1] + ps2[i + 1][j] - ps2[i][j] + mat[i][j];
    }
  }

  // Заметь, что первая строка и первый столбец
  // у префикс-сумм равны нулям.
  cout << "Initial matrix:" << endl;
  print(mat);
  cout << endl;
  cout << "2D prefix-sums:" << endl;
  print(ps2);
  cout << endl;

  // Функция (в математике) - зависимость одной переменной (y) от другой (x)

  // Монотонно возрастающая функция - функция, которая при увеличении
  // аргумента УВЕЛИЧИВАЕТ своё значение (если увеличился x, то увеличился и y)
  // f(x + a) > f(x): a > 0

  // Монотонно убывающая функция - функция, которая при увеличении
  // аргумента УМЕНЬШАЕТ своё значение (если увеличился x, то y уменьшился)
  // f(x + a) < f(x): a > 0

  // Бинарный поиск - алгоритм нахождения аргумента монотонной
  // функции с подходящим значением. Для этого делим
  // отрезок возможных значений пополам и убираем одну из
  // половин. Смотри файл BS.gif для лучшего понимания
  // или слайды из папки "resources"
  // Идею "подели пополам" мы уже видели в сортировке слиянием.

  // Вот пример задачи с бинарным поиском:
  // https://codeforces.com/group/U86Pj3Hohe/contest/429290/problem/F

  // Решение такое: отсортируем массив по возрастанию.
  // Тогда в нём будет монотонность.
  // Чем больше индекс элемента, тем больше его значение.
  sort(arr.begin(), arr.end());

  int have = 3;

  // Затем сам бинарный поиск. Всегда выбирай в качестве границ
  // что-то осмысленное. Тут, например:

  // В скольки магазинах точно сможем купить
  int l = 0;
  // В скольки магазинах точно не сможем купить.
  int r = n + 1;

  // ОБЯЗАТЕЛЬНО ПОДПИСЫВАЙ ЧТО ОЗНАЧАЮТ ГРАНИЦЫ В КОДЕ!!!

  // Теперь сам бинарный поиск.
  // Длина отрезка [l, r] вычисляется по формуле length = r - l + 1
  // Мы можем делить его пополам пока длина больше двух.
  // Если длина равна двум, то середина упадёт на одну из существующих
  // границ.

  // while (r - l + 1 > 2) {
  // Но обычно пишут так:
  while (r - l > 1) {
    // Считаем середину. Связь с сортировкой слиянием.
    int mid = l + (r - l) / 2;
    // Считаем индекс по которому нужно будет посмотреть в массив:
    int ind = mid - 1;
    // Теперь самый важный момент. Мы пишем условие на середину
    // и сразу знаем какую границу двинуть. Мы же это подписали!!!
    if (arr[ind] <= have) {
      l = mid;
    } else {
      r = mid;
    }
  }
  // После выхода нужно понять где ответ.
  // Но мы же подписали границы! Это и так понятно!
  int ans = l;

  // Пресловутое применение бинарного поиска - найти элемент
  // в отсортированном массиве. Существуют целых 3 стандартные
  // функции в c++, которые это делают за нас:

  // Итератор на первый элемент, который больше или равен данному:
  auto le = lower_bound(arr.begin(), arr.end(), have);
  // Итератор на первй элемент, который строго больше данного:
  auto g = upper_bound(arr.begin(), arr.end(), have);
  // true/false - есть/нет элемент в массиве
  bool present = binary_search(arr.begin(), arr.end(), have);

  // Главным и единственным фактором наличия бинарного поиска является
  // монотонность. Увидел монотонность - подумал в бинарный поиск.
  // Иногда её не просто увидеть или нужно заставить задачу быть монотонной.


  // Наконец, два указателя.
  // Два указателя - способ решения задач, где есть две или более
  // монотонные последовательности чисел (возможно одна и та же
  // последовательность рассмотренная дважды).

  // Мы уже встречались с двумя указателями в сортировке слиянием.
  // Там были две отсортированные половины и нужно было их слить
  // в одну отсортированную часть. Смотри файл TP.gif, чтобы вспомнить.
  // Одна последовательность чисел - отсортированная левая половина.
  // Вторая последовательность чисел - отсортированная правая половина.

  // Можно решить задачи, которые мы уже видели в лекции. Например:

  // "Найди подотрезок с суммой равной x" при условии, что все элементы
  // массива положительные.

  // (В ЗАДАЧЕ ИЗ НАБОРА ОНИ МОГУТ БЫТЬ ОТРИЦАТЕЛЬНЫМИ!!!)

  // Наш отрезок представляется двумя границами - левой и правой.
  // Мы можем каждую из них сдвинуть.
  // Если увеличиваем правую, то сумма увеличивается. Отрезок увеличивается.
  // Если увеличиваем левую, то сумма уменьшается. Отрезок уменьшается.
  // Если сумма текущего отрезка меньше x, то нужно его расширять, чтобы
  // увеличить сумму.
  // Почему не двигать левую? Потому что тогда сумма уменьшится
  // ещё сильнее и нам в любом случае придётся двигать правую.
  // Одна последовательность чисел - список правых границ.
  // Вторая последовательность чисел - список левых границ.
  // Эти два списка совпадают, но в этом нет ничего страшного.
  // Главное, что выполняется "если сдвинем правую, то сумма увеличится,
  // а если сдвинем левую, то уменьшится".

  // Задачу "Интересный напиток" можно решить двумя указателями.
  // Для этого отсортируем не только массив с ценами магазинов, но и
  // сами запросы. Нужно для каждого запроса запомнить его индекс, ведь
  // после сортировки мы не будем знать на какой по счёту запрос мы отвечаем.
  // Чем больше денег - тем в большем количестве магазинов мы сможем купить.
  // Вот и монотонности. "Больше денег" и "больше покупок".
  // Одна последовательность чисел - цены в магазинах.
  // Вторая последовательность чисел - количество денег в очередной день.

  // Наконец, задача:
  // https://codeforces.com/group/U86Pj3Hohe/contest/429290/problem/K
  // Пускай мы хотим сделать два элемента равными. Тогда если в первом
  // массиве получается число меньше, то надо добавлять к нему, иначе к
  // числу во втором массиве. Это работает потому что элементы положительные
  // и при добавлении очередного элемента число не может уменьшится.
  // Чем больше добавили элементов - тем больше сумма. Монотонность.
  // Первая и вторая последовательности это элементы первого и второго
  // массива соответственно.

  n = 5;
  arr = {11, 2, 3, 5, 7};
  m = 4;
  vector<int> brr = {11, 7, 3, 7};
  ans = 0;
  int p1 = 0, p2 = 0;
  int sum1 = 0, sum2 = 0;
  while (p1 < n && p2 < m) {
    if (sum1 == 0 || sum1 < sum2) {
      sum1 += arr[p1];
      ++p1;
    } else if (sum2 == 0 || sum2 < sum1) {
      sum2 += arr[p2];
      ++p2;
    } else {
      sum1 = sum2 = 0;
      ++ans;
    }
  }
  while (p1 < n) {
    sum1 += arr[p1];
    ++p1;
  }
  while (p2 < m) {
    sum2 += arr[p2];
    ++p2;
  }
  if (sum1 == sum2) {
    cout << ans + 1 << endl;
  } else {
    cout << -1 << endl;
  }

  return 0;
}
