#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define int ll

// Это простое число, которое часто встречается в задачах.
const int MOD = 1e9 + 7;

class Combinatorics {
/* Класс написан так, что можно убрать #define int ll
 * и ничего не сломается. Поэтому везде можно увидеть
 * 1LL * ...
 * Это сделано для того, чтобы умножение происходило
 * в типе long long, но после этого сохранялось в типе int
 */
private:
  int pown(int n, int power) {
    int res = 1;
    while (power > 0) {
      if (power & 1) {
        res = int(1LL * res * n % MOD);
      }
      n = int(1LL * n * n % MOD);
      power >>= 1;
    }
    return res;
  }

public:
  vector<int> facts, ifacts;
  Combinatorics(const int A) {
    facts.resize(A + 1);
    ifacts.resize(A + 1);
    facts[0] = ifacts[0] = 1;
    for (int i = 1; i <= A; ++i) {
      facts[i] = int(1LL * facts[i - 1] * i % MOD);
    }
    ifacts[A] = this->pown(facts[A], MOD - 2);
    for (int i = A - 1; i > 0; --i) {
      ifacts[i] = ((i + 1) * ifacts[i + 1]) % MOD;
    }
  }

  // Две строчки, а смысла в них на 400 строк лекции :D
  int cnk(int n, int k) {
    return facts[n] * (1LL * ifacts[k] * ifacts[n - k] % MOD) % MOD;
  }

  int ank(int n, int k) {
    return 1LL * facts[n] * ifacts[n - k] % MOD;
  }
} comb(2e5);

void gen() {
  string s = "aab";
  int n = (int)s.size();
  vector<int> perm(n);
  iota(perm.begin(), perm.end(), 0);
  do {
    for (int i = 0; i < n; ++i) {
      cout << s[perm[i]] << ' ';
    }
    cout << endl;
    for (int i = 0; i < n; ++i) {
      cout << perm[i] + 1 << ' ';
    }
    cout << endl << endl;
  } while (next_permutation(perm.begin(), perm.end()));
}

signed main() {
  string dummy;
  // Остаток от деления (модуль) - число r = a % b такое, что:
  // 0 <= r < b, a = k * b + r для некого целого k
  // В таком определении r вычисляется однозначно.

  //  a  %  b = r   a  =   k  *   b  + r
  //  10 %  7 = 3;  10 =   1  *   7  + 3 =   7 + 3 =  10
  // -10 %  7 = 4; -10 = (-2) *   7  + 4 = -14 + 4 = -10
  //  10 % -7 = 3;  10 = (-1) * (-7) + 3 =   7 + 3 =  10
  // -10 % -7 = 4; -10 =   2  * (-7) + 4 = -14 + 4 = -10

  // Однако у c++ своё видение остатка. Он его вычисляет из
  // выражения
  // a = a / b * b + a % b
  // a % b = a - a / b * b
  // Результаты такие:
  cout << " 10 %  7 = " << 10 % 7 << endl;
  cout << "-10 %  7 = " << -10 % 7 << endl;
  cout << " 10 % -7 = " << 10 % -7 << endl;
  cout << "-10 % -7 = " << -10 % -7 << endl;
  getline(cin, dummy);
  // Это лечится. Если остаток отрицательный, то к нему
  // можно прибавить abs(b). Это всё равно что увеличить k на 1.
  // Запомни. Остаток ВСЕГДА обязан находиться в пределах
  // 0 <= r < b.

  // Попробуем посчитать остатки от деления на 7 руками.
  // Вычислим 1000 % 7. Гуль zxc в такой ситуации
  // предложил бы вычитать семёрки пока очередное вычитание
  // не будет нарушать неотрицательность числа.
  // Однако мы можем воспользоваться свойствами остатка от
  // деления:
  // (a + b) % m = (a % m + b % m) % m
  // (a - b) % m = (a % m - b % m) % m
  // (a * b) % m = ((a % m) * (b % m)) % m
  // Про свойство a / b % m позже.

  // 1000 % 7 = (300 % 7 + 700 % 7) % 7 = 300 % 7
  // 300 % 7 = (20 % 7 + 280 % 7) % 7 = 20 % 7
  // 20 % 7 = (6 % 7 + 14 % 7) % 7 = 6
  // 1000 % 7 = 6

  cout << "1000 % 7 = " << 1000 % 7 << endl;
  getline(cin, dummy);

  // Далеко не каждый гуль умеет вычислять 10^100 % 7.
  // Для этого вспомним полиномиальное представление числа.
  // Именно оттуда берутся свойства делимости.

  // 123 = 1 * 100 + 2 * 10 + 3 * 1
  // 123 % 2 = (1 * 100) % 2 + (2 * 10) % 2 + (3 * 1) % 2
  // 123 % 2 = 0 + 0 + 1 = 1
  // Можно заметить, что любая степень десятки делится на 2.
  // Поэтому не имеет смысла смотреть на какие-либо разряды
  // кроме младшего. Какие цифры чётные, а какие нет легко
  // запомнить.

  // По сути нас интересует сумма выражений вида
  // d * 10^p, где d - цифра p - показатель от 0 до x.
  // d % m нам особо ничего не даст, а вот 10^p % m нужно
  // подробно рассмотреть.

  // 10^0 % 3 = 1
  // 10^1 % 3 = 1
  // 10^2 % 3 = 1
  // ...
  // 10^k % 3 = 1
  // Можно доказать это по индукции, если сильно хочется.
  // 10^0 % 3 = 1 базовый случай.
  // 1 * 10 = 10, 10 % 3 = 1 и так далее.
  // Из этого следует, что нас вообще не интересует часть
  // 10^p при поиске остатка от деления на 3.
  // Отсюда и свойство. Остаток от деления на 3 равен
  // Остататку от деления суммы цифр на 3.
  // 123 % 3 = (1 + 2 + 3) % 3 = 0

  // Для 4 аналогично 2, нужно смотреть на 2 последние
  // цифры, т.к. 100 * 10^x % 4 = 0.
  // То есть все разряды старше второго обнулятся из-за этого.

  // Для 5 тоже аналогично 2. Интересна только последняя
  // цифра, т.к. 10^x % 5 = 0 (x > 0).

  // Для 6:
  // 10^0 % 6 = 1
  // 10^1 % 6 = 4
  // 10^2 % 6 = (10^1) * (10^1) = 4 * 4 = 16 % 6 = 4
  // ...
  // 10^x % 6 = 4 (x > 0)
  // Легко видеть свойство. При вычислении остатка от деления
  // на 6 интересна сумма самой младшей цифры с учетверённой
  // суммой остальных цифр.
  // 123 % 6 = 3 + 4 * (2 + 1) = 3 + 12 = 15 % 6 = 3

  // Казалось бы изи, но вот с 7 начинается беда.
  // 10^0 % 7 = 1
  // 10^1 % 7 = 3
  // 10^2 % 7 = 2
  // 10^3 % 7 = 6
  // 10^4 % 7 = 4
  // 10^5 % 7 = 5
  // 10^6 % 7 = 1
  // 10^7 % 7 = 3
  // Но вот же интересно. Остатков от деления на 7 всего
  // 7 штук существует. 0 не мог тут появиться, иначе
  // все последующие степени имели бы остаток от деления 0
  // на 7. В какой-то момент остатки начали повторяться с
  // периодом 6. Пусть это пока будет нашей эмперической
  // находкой. Забегая вперёд, скажу, что такая же картина
  // будет наблюдаться для любого числа в степени,
  // взаимнопростого с 7. То есть такого, которое не имеет
  // общих делителей с 7.

  // Нам повезло, т.к. в числе 10^100 всего одна единица.
  // Осталось только понять какой остаток даст эта единица
  // в нашей периодической таблице zxc. Через каждые 6
  // умножений наша таблица повторяется. Значит, нужно
  // найти 100 % 6. Хорошо, что мы это уже умеем делать.
  // 100    % 6 = 4
  // 10^4   % 7 = 4
  // 10^100 % 7 = 4
  // Калькулятор подтвердит.

  for (int m = 2; m <= 7; ++m) {
    cout << "123 % " << m << " = " << 123 % m << endl;
  }
  getline(cin, dummy);
  int p = 1;
  for (int i = 0; i <= 20; ++i) {
    cout << "10^" << i << " % 7 = " << p << endl;
    (p *= 10) %= 7;
  }
  getline(cin, dummy);
  p = 1;
  for (int i = 0; i < 100; ++i) {
    (p *= 10) %= 7;
  }
  cout << "10^100 % 7 = " << p << endl;
  getline(cin, dummy);

  // На самом деле мы только что руками придумали
  // Малую теорему Ферма (МтФ)
  // https://ru.wikipedia.org/wiki/Малая_теорема_Ферма
  // Она гласит:
  // Если p - простое, a - целое, не делящееся на p, то
  // a^(p-1) = 1 mod p
  // Говорят "a^(p-1) сравнимо с 1 по модулю p"
  // Грубо говоря, это и есть остаток от деления на p.
  // Из МтФ следует свойство, которым мы воспользовались.
  // a^x mod p = a^(x + (p-1)) mod p = a^x * a^(p-1) mod p =
  // = a^x * 1 mod p = a^x mod p
  // То есть сколько раз не прибавляй (p-1) в степень, от
  // этого результат не изменится. Аналогично с вычитанием.
  // Полученное свойство формулируется как:
  // a^x = a^(x mod (p-1)) mod p
  // Конечно же, не забываем про условия, что
  // a - целое, p - простое, a не делится на p.

  // Обещанное доказательство того, что мы получим все
  // остатки при умножении k самого на себя по модулю p.
  // p обязанно быть простым, k не должно быть кратно p.
  // Докажем, что при умножении любого числа [1, p) на k
  // каждый раз будем получать разный остаток.
  // Докажем от противного. Пусть возьмём два числа
  // a, b из остатков [1, p), a != b. Значит,
  // a * k и b * k дают один и тот же остаток (опровергаемое
  // утверждение). Но это же означает, что их разность
  // будет делиться на p.
  // a * k - b * k = (a - b) * k = 0 mod p
  // ведь a и b дают один и тот же остаток.
  // Но это невозможно, ведь a - b не может быть кратно
  // p. Не получится найти такую пару чисел из остатков
  // [1, p) a != b, что они дают 0 в остатке при умножении на k.
  // Итого. У нас. Зафиксировали k. Умножаем его само на
  // себя p - 1 раз и каждый раз будем получать новый
  // остаток, умножать его на k и так далее, пока не получим
  // все p - 1 остатков.

  // Отсюда, кстати, и доказательство МтФ.
  // Зафиксировали a. Умножим его последовательно на
  // каждый остаток [1, p). Согласно доказанной выше лемме
  // что мы каждый раз новый остаток получаем можем записать:
  // a * 2a * ... * (p-1)a = 1 * 2 * ... * (p-1) mod p.
  // Может, мы получим остатки в другом порядке, но ведь
  // от перестановки мест множителей произведение
  // не меняется. Математически причешем выражение:
  // a^(p-1) * (p-1)! = (p-1)! mod p
  // Сократим факториалы.
  // a^(p-1) = 1 mod p
  // Что и требовалось доказать.

  // Теперь про a / b % m.
  // Что делать, если a не делится на b?
  // Запишем чуть по-другому, перейдём к умножению:
  // a / b % m = a * b^(-1) % m
  // По сути, нужно найти такое число, которое ведёт
  // себя как b^(-1) и умножить на него.
  // Число b^(-1) называется обратным по модулю.
  // Тут нам поможет только что изученная МтФ:
  // a^(p-1) = 1 mod p; умножим обе части на a^(-1)
  // a^(p-1) * a^(-1) = a^(-1) mod p;
  // a^(p-2) = a^(-1) mod p; перевенём
  // a^(-1) = a^(p-2) mod p.

  // Очень важное замечание!
  // Обратный элемент по модулю МОЖЕТ существовать, когда
  // p не простое, но это ломает МтФ. Как находить обратный
  // по модулю в случае составного p расскажу в
  // дополнительной лекции.

  // Однако остаётся вопрос. Как считать a^(p-2), когда p
  // может быть очень большим, порядка миллиарда?
  // На помощь приходит алгоритм быстрого возведения в
  // степень (БВвС).

  // Пусть хотим посчитать a^b.
  // Можно это сделать, b раз умножив 1 на a, т.е.
  // a^b = a * a * a * ... * a * a
  //       ----------------------- их b штук
  // Очевидно, это O(b), что слишком долго. Хотим быстрее.
  // Продемонстрируем работу алгоритма на примере:
  // 3^10 = ?; Переведём степень в двоичную СС
  // 10_10 = 1010_2
  // 3^1010_2 = ?
  // 3^1010_2 = 3^1000_2 * 3^10_2
  // Оказывается, a^(100..00_2) очень легко считать!
  // 3^0000_2 = 1
  // 3^0001_2 = 3
  // 3^0010_2 = 3^1 * 3^1 = 3 * 3 = 9
  // 3^0100_2 = 3^2 * 3^2 = 9 * 9 = 81
  // 3^1000_2 = 3^4 * 3^4 = 81 * 81 = 6561
  // Осталось умножить 1 на необходимые степени двойки.
  // 3^1010_2 = 3^1000_2 * 3^10_2 = 6561 * 81 = 59049
  // Итого, мы сделали O(log_2(b)) умножений, ведь
  // число значащих бит в числе не превышает логарифма.
  // С модулем просто каждый раз берём его после каждой
  // операции. Реализуем.

  auto regular_pow = [](int a, int b) {
    int res = 1;
    for (int i = 0; i < b; ++i) {
      (res *= a) %= MOD;
    }
    return res;
  };
  auto binary_pow = [](int a, int b) {
    int res = 1;
    while (b > 0) {
      if (b & 1) {
        // res = (res * a) % MOD
        (res *= a) %= MOD;
      }
      // a = (a * a) % MOD;
      (a *= a) %= MOD;
      b >>= 1;
    }
    return res;
  };
  cout << "Regular pow:" << endl;
  cout << regular_pow(12345, 6789) << endl;
  cout << "Binary pow:" << endl;
  cout << binary_pow(12345, 6789) << endl;
  getline(cin, dummy);

  // Пример реализации функции деления по модулю:
  auto mod_div = [&](int a, int b, const int modulo) {
    int b_inverse = binary_pow(b, modulo - 2);
    return (a * b_inverse) % modulo;
  };
  int res = mod_div(5, 3, 7);
  cout << "5 / 3 mod 7 = " << res << endl;
  cout << res << " * 3 = " << (res * 3 % 7) << " mod 7" << endl;

  // ДОСКА!!!
  // Теперь к комбинаторике. Про неё немного.
  // Задача. В столовой есть n видов фруктов и m видов
  // овощей. Сколько существует способов выбрать один
  // фрукт и один овощ?
  // Лучший способ объяснить комбинаторику - с помощью
  // деревьев. Пусть мы сначала выбираем фрукт, потом
  // овощ. В задаче не говорят, что нам важен порядок.
  // Корень дерева - состояние, когда мы не выбрали
  // ещё ничего. Из корня есть n рёбер. Одно для каждого
  // фрукта. Получается, что после того, как мы выбрали
  // фрукт, на глубине 1 (корень имеет глубину 0) есть
  // n состояний или вершин. По одному для каждого фрукта.
  // Теперь мы выбираем овощ. Из каждого из n состояний
  // существует m рёбер. Одно для каждого овоща.
  // Получается, что на глубине 2 существует n*m вершин.
  // По одной для каждой пары (фрукт, овощ). Ответ: n*m
  // В любой непонятной ситуации на комбинаторику нужно
  // представить задачу в виде дерева, как я показал.

  // Рассмотрим такой комбинаторный объект как перестановка.
  // Это набор чисел от 1 до n, где каждое число встречается
  // ровно один раз. Вопрос. Сколько всего существует
  // перестановок длины n?
  // Воображаем дерево. Есть корень. Как бы перестановка
  // длины 0. Из вершины на глубине 0 (корня) исходит
  // n рёбер, т.к. можем взять любое число. На глубине
  // 1 мы одно какое-то число взяли, осталось n-1.
  // Именно столько рёбер будет у каждой вершины на глубине
  // 1. Итого. На глубине 2 будет n * (n - 1) вершин.
  // Аналогично рассуждая далее, мы поймём, что листьев
  // (т.е. перестановок длины n) будет n!

  // В комбинаторике существует такое понятие как
  // размещения. Размещение на n позиций k элементов
  // Ank - количество способов разместить k объектов
  // на n позиций. Снова представляем дерево и в итоге
  // получим Ank = n * (n-1) * ... * (n-k+1)
  // Записываем формулой:
  // Ank = n! / (n-k)!
  // Если раскрыть, то получится то же самое, что и мы
  // записали до этого:
  // Ank = n * (n-1) * ... * (n-k+1) * (n-k)! / (n-k)!
  // Ank = n * (n-1) * ... * (n-k+1)
  // По сути мы ответили на вопрос "сколько существует
  // способов выбрать k предметов из n, если способы,
  // отличающиеся только порядком выбора считаются
  // различными. Т.е. {1, 2, 3} и {3, 2, 1} - два разных
  // способа".

  // Также существует понятие сочетаний. Это те же самые
  // размещения, где способы {1, 2, 3} и {3, 2, 1} считаются
  // одинаковыми. Сочетаниям не интересно, кушаешь ли ты
  // пюре со свёклой и свёклу с пюре. Формально.
  // Сочетаниями из n элементов по k называется величина
  // Cnk - количество способов выбрать из n объектов k
  // без учёта порядка. Как они считаются? Начнём с
  // размещений. То есть, выбрали объекты, но порядок пока
  // важен. Значит, нужно избавиться от него. Вот мы выбрали
  // 3 объекта из n (размещения). Существует 6 способов это
  // сделать для каждой тройки объектов:
  // (a, b, c)
  // (a, c, b)
  // (b, a, c)
  // (b, c, a)
  // (c, a, b)
  // (c, b, a)
  // Так это же и есть все перестановки длины 3.
  // Удалим эти способы, поделив на 3!. Тогда останутся
  // просто "способы выбрать тройку из n". Поделим Ank на k!:
  // Cnk = n! / ((n-k)! * k!).
  // Чаще всего в задачах встречаются сочетания.
  // Приведу примеры как можно применить размещения и сочетания.

  // Пусть мы двумя форами ищем пару элементов и нам
  // важен порядок. Один и тот же элемент нельзя выбирать.
  vector<int> arr = {5, 3, 7, 10};
  const int N = (int)arr.size();
  res = 0;
  for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
      if (i == j) {
        continue;
      }
      (res += binary_pow(arr[i], arr[j])) %= MOD;
    }
  }
  // Мы сделаем n * n - n вызовов функции binary_pow().
  // n * n - n = n * (n-1).
  // Можно то же самое получить с помощью размещений.
  // Ank(n, 2) = n! / (n-2)! = n * (n-1) * (n-2)! / (n-2)! =
  // = n * (n-1)

  // Пусть не важен порядок.
  res = 0;
  for (int i = 0; i < N; ++i) {
    for (int j = 0; j < i; ++j) {
      (res += arr[i] * arr[j]) %= MOD;
    }
  }
  getline(cin, dummy);
  // Ранее я рассказывал как тут посчитать количество
  // итераций с помощью арифметической прогрессии.
  // Теперь можно пользоваться сочетаниями.
  // Cnk(n, 2) = n! / ((n-2)! * 2!) =
  // = n * (n-1) * (n-2)! / (n-2)! / 2 =
  // = n * (n-1) / 2.

  // Наконец. Как считать это по модулю?
  // Факториалы обычно можно посчитать заранее в отдельном
  // массиве. Чтобы поделить по модулю, нужно посчитать
  // обратный по модулю. Каждое такое вычисление
  // будет работать за O(log(p)). Можно на этом остановиться,
  // Но можно и избавиться от логарифма в асимптотике.

  // Cnk(n, k) = n! / ((n-k)! * k!) =
  // = n! * (n-k)!^(-1) * k!^(-1)
  // То есть нам нужны обратные факториалы по модулю p.
  // Их тоже можно предпосчитать. И сделать это тоже за
  // линию. Посчитаем последний нужный факториал с помощью
  // БВвС за O(log(p)). Всё остальное можно вычислить
  // по незамысловатой формуле.
  // n! = n * (n-1)!
  // (n-1)! = n! / n
  // 1/(n-1)! = n / n!
  // (n-1)!^(-1) = n * n!^(-1)
  // n!^(-1) = (n+1) * (n+1)!^(-1)
  // Теперь можно считать Ank и Cnk за O(1).
  // Смотри реализацию такого класса в начале файла.

  gen();
  return 0;
}
