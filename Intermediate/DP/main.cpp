#include <bits/stdc++.h>

using namespace std;

const int MOD = 1e9 + 7;

// ДП "назад":
int solve_grasshopper_backward(string &s) {
  int n = (int)s.size();
  vector<int> dp(n);
  dp[0] = 1;
  for (int i = 1; i < n; ++i) {
    if (s[i] == '*') {
      continue;
    }
    dp[i] = dp[i - 1];
    if (i > 1) {
      dp[i] += dp[i - 2];
      dp[i] %= MOD;
    }
    if (i > 2) {
      dp[i] += dp[i - 3];
      dp[i] %= MOD;
    }
  }
  return dp[n - 1];
}

// ДП "вперёд":
int solve_grasshopper_forward(string &s) {
  int n = (int)s.size();
  vector<int> dp(n);
  dp[0] = 1;
  for (int i = 0; i + 1 < n; ++i) {
    if (s[i + 1] == '.') {
      dp[i + 1] += dp[i];
      dp[i + 1] %= MOD;
    }
    if (i + 2 < n && s[i + 2] == '.') {
      dp[i + 2] += dp[i];
      dp[i + 2] %= MOD;
    }
    if (i + 3 < n && s[i + 3] == '.') {
      dp[i + 3] += dp[i];
      dp[i + 3] %= MOD;
    }
  }
  return dp[n - 1];
}

// Рюкзак n*S памяти
int solve_knapsack_nS(vector<int> &hs, vector<int> &ss, int S) {
  const int INF = 2e9;
  int n = (int)hs.size();
  vector<vector<int>> dp(n + 1, vector<int>(S + 1, -INF));
  dp[0][0] = 0;
  for (int i = 0; i < n; ++i) {
    // Пропускаем предмет
    dp[i + 1] = dp[i];
    // Берём предмет
    for (int j = 0; j + hs[i] <= S; ++j) {
      dp[i + 1][j + hs[i]] = max(dp[i + 1][j + hs[i]], dp[i][j] + ss[i]);
    }
  }
  int ans = *max_element(dp[n].begin(), dp[n].end());
  return ans;
}

// Рюкзак 2*S памяти
int solve_knapsack_2S(vector<int> &hs, vector<int> &ss, int S) {
  const int INF = 2e9;
  const int LAYERS = 2;
  const int CUR = 0;
  const int NEXT = 1;
  int n = (int)hs.size();
  vector<vector<int>> dp(LAYERS, vector<int>(S + 1, -INF));
  dp[CUR][0] = 0;
  for (int i = 0; i < n; ++i) {
    // Пропускаем предмет
    dp[NEXT] = dp[CUR];
    // Берём предмет
    for (int j = 0; j + hs[i] <= S; ++j) {
      dp[NEXT][j + hs[i]] = max(dp[NEXT][j + hs[i]], dp[CUR][j] + ss[i]);
    }
    // swap векторов работает за O(1)
    swap(dp[CUR], dp[NEXT]);
  }
  int ans = *max_element(dp[CUR].begin(), dp[CUR].end());
  return ans;
}

// Рюкзак S памяти
int solve_knapsack_S(vector<int> &hs, vector<int> &ss, int S) {
  const int INF = 2e9;
  int n = (int)hs.size();
  vector<int> dp(S + 1, -INF);
  dp[0] = 0;
  for (int i = 0; i < n; ++i) {
    // Берём предмет
    for (int j = S - hs[i]; j >= 0; --j) {
      dp[j + hs[i]] = max(dp[j + hs[i]], dp[j] + ss[i]);
    }
  }
  int ans = *max_element(dp.begin(), dp.end());
  return ans;
}

// Рюкзак, когда каждый предмет можно брать неограниченное число раз
int solve_knapsack_multiple_items(vector<int> &hs, vector<int> &ss, int S) {
  const int INF = 2e9;
  int n = (int)hs.size();
  vector<int> dp(S + 1, -INF);
  dp[0] = 0;
  for (int i = 0; i < n; ++i) {
    // Берём предмет
    for (int j = 0; j + hs[i] <= S; ++j) {
      dp[j + hs[i]] = max(dp[j + hs[i]], dp[j] + ss[i]);
    }
  }
  int ans = *max_element(dp.begin(), dp.end());
  return ans;
}

// Игра с лампочками:
int solve_bulb_game(int n) {
  vector<bool> dp(n + 1, false);
  for (int i = 1; i <= n; ++i) {
    bool win = (dp[i - 1] == false);
    if (i > 1 && dp[i - 2] == false) {
      win = true;
    }
    if (i > 2 && dp[i - 3] == false) {
      win = true;
    }
    dp[i] = win;
  }
  if (dp[i]) {
    return 1;
  } else {
    return 2;
  }
}

int main() {
  // Динамическое программирование (динамика) - метод решения задач,
  // гласящий, что значения для одних состояний задачи можно
  // последовательно вычислить через значения предыдущих состояний,
  // связанных с первыми при помощи действий, переходов.
  // Отсюда и слово "динамика" - одни состояния переходят
  // в другие.

  // Любая задача на динамику подразумевает наличие четырёх компонентов -
  // состояния, база, переходы и ответ на задачу.

  // 1. Состояния - ситуации, которые возникают в ходе решения задачи.
  // Их описывают (кодируют) при помощи параметров. Например, день
  // можно описать как солнечный/пасмурный, как холодный/тёплый или
  // скоростью и направлением ветра. Это и есть параметры состояния дня.
  // Каждому состоянию соответствует значение. Например, стоимость или
  // красота. Состояния можно представить как вершины в графе.

  // 2. База - начальные состояния, значения для которых известны
  // заранее, до начала решения задачи. Эти значения обычно
  // задаются отдельно.

  // 3. Переходы - действия, которые можно совершать в состояниях задачи
  // Именно они связывают между собой состояния. Переходы можно
  // представить как ориентированные рёбра в графе.

  // 4. Ответ на задачу чаще всего является значением какого-то
  // конечного состояния, но иногда он может являться одним из
  // измерений, значение и остальные параметры которого удовлетворяют
  // условию задачи.

  // Таким образом, если построить граф, состоящий из вершин-состояний
  // и рёбер-переходов, то должен получиться Ориентированный Ацикличный
  // Граф (ОАГ, DAG - Directed Acyclic Graph). Если в построенном графе
  // оказались циклы, то динамика провалится и задача скорее всего
  // сводится к решению Системы Линейный Алгебраический Уравнений
  // (СЛАУ) методом Гаусса.

  // Теперь можно вычислить значение для состояния, если известны
  // значения всех предыдущих состояний. То есть воспользоваться динамикой.

  // Различают два подхода к реализации подсчёта значений с помощью
  // переходов. Они называются динамикой "назад" - традиционный вариант
  // и динамика "вперёд", который иногда более удобен. Рассмотрим оба на
  // примере задачи про кузнечика. Это классическая задача на ДП.

  // https://codeforces.com/group/U86Pj3Hohe/contest/450277/problem/A

  // Разберём по пунктам.
  // 1. Состояния. В этой задаче всё просто. Состояние характеризуется
  // номером полянки, на которой находится кузнечик. Значение -
  // количество способов в неё попасть по модулю. Обязательно записываем:
  // dp[i] = количество способов попасть в i-ю полянку.
  // 2. База. Количество способов попасть на первую полянку равно 1.
  // Можно просто ничего не делать и попасть туда.
  // dp[1] = 1.
  // 3. Переходы. В задаче явно говорят что происходит. Кузнечик прыгает
  // по полянкам. Разберём динамику "назад" и "вперёд".
  // "Назад": Вычислим значение для очередной полянки, зная значения
  // предыдущих. Чтобы мы всегда знали значения предыдущих состояний,
  // обработаем их слева-направо. От 1-й до n-й полянки. В i-ю полянку
  // мы можем попасть из полянок i-1, i-2 и i-3. Значит значение
  // очередного состояния будет равно сумме предыдущих трёх состояний:
  // dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3].
  // "Вперёд": Когда приходим в очередную полянку, то хотим быть уверены,
  // что её значение уже посчитано. Это достигается тем же способом, что
  // и в прошлый раз. Обработаем полянки слева-направо от 1-й до n-й.
  // Когда приходим в полянку, то обновим значения для следующих трёх
  // полянок. Как бы "прыгнем" кузнечиком в эти состояния:
  // dp[i + 1] += dp[i], dp[i + 2] += dp[i], dp[i + 3] += dp[i].
  // Нужно не забыть про выход за границы и модуль.
  // 4. Ответ на задачу. Это просто значение в последней полянке.
  // Нас же просили узнать количество способов попасть именно туда.
  // ans = dp[n].
  // Эти четыре пункта должны быть в каждой задаче на ДП.
  // Пример реализации в начале файла.
  // К слову, префиксные суммы - самый простой пример динамики.

  // Рассмотрим классическую задачу о рюкзаке.
  // Формально, есть рюкзак вместимостью S <= 10^5.
  // Есть n <= 1000 предметов у каждого из которых есть
  // вес h_i и цена s_i (1 <= h_i, s_i <= 1000)
  // Можно брать предметы в рюкзак пока сумма их весов
  // не превосходит S. Какую максимальную суммарную стоимость
  // можно набрать?

  // Решение такое:
  // 1. dp[i][j] = максимальная стоимость, которую можно набрать
  // когда мы РАССМОТРЕЛИ i предметов и набрали суммарный вес j.
  // 2. dp[0][0] = 0. Можно ничего не делать и набрать стоимость 0
  // dp[i][j] = -INF. Остальные пока не можем набрать.
  // 3. На каждой итерации можно брать предмет или не брать.
  // Не берём: dp[i + 1] = dp[i]
  // Берём: dp[i + 1][j + h_i] = max(dp[i + 1][j + h_i], dp[i][j] + s_i);
  // 4. Ответ - max(dp[n])

  // Данное решение потребляет O(n*S) памяти. Это можно улучшить,
  // написав "двухслойку".
  // На каждой итерации мы смотрим в значения dp[i] и dp[i + 1], то
  // есть количество предметов за раз увеличивается на один.
  // Значит нам не имеет смысла хранить одновременно все остальные dp[..]
  // Тогда решение будет потреблять 2*S памяти.
  // Это решение можно ещё улучшить до S потребляемой памяти.
  // Когда мы находимся в состоянии dp[CUR][j], то мы смотрим только
  // в "следующие" состояния dp[NEXT][j + h_i]. Если мы напишем один
  // слой, то получится, что мы сможем брать один и тот же предмет
  // несколько раз. То есть сначала обработаем j = a, потом j = a + h_i,
  // обновлённое этим же предметом. Чтобы такого не происходило, нужно
  // перебирать j в порядке уменьшения, а не увеличения.
  // Смотри примеры в начале файла.

  // Рассмотрим "особый" вид динамики - игры. Задача:
  // Пускай есть табло с n лампочками. Играют по очереди два игрока.
  // В свой ход игрок может выключить 1, 2 или 3 лампочки.
  // Игрок, который не может сделать ход проигрывает.
  // Кто выйграет при оптимальной игре?
  // Похожие задачи с кучами камней часто встречаются в ЕГЭ.
  // Они решаются "ретроспективным анализом" или динамикой.
  // 1. dp[i] = кто выйграет, если осталось i лампочек.
  // 2. dp[0] = 2. Если лампочек не осталось, то выйграет второй игрок
  // 3. На каждом ходу будем пытаться сделать такой ход,
  // чтобы попасть в состояние, где выйграет второй игрок, ведь
  // мы будем вторым игроком, передав очередь хода.
  // dp[i] = 1, если dp[i - 1], dp[i - 2] или dp[i - 3] равно 2.
  // dp[i] = 2 иначе.
  // 4. Ответ - dp[n].
  // Можно заметить, что массив dp будет иметь очень характерный вид:
  // 0123456789
  // 2111211121
  // Можно сказать, что если n делится на 4, то выйгрывает
  // второй игрок, иначе - первый.
  // Обычно состояния, в которых выйгрывает второй игрок
  // называют "проигрышными", потому что в них проигрываешь.
  // Состояния, в который выйгрывает первый игрок - "выйгрышными".
  // Смотри пример в начале файла.
  return 0;
}
